using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using SportsStore.Models;
using SportsStore.Models.ViewModels;

// For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860

namespace SportsStore.Controllers
{
    public class ProductController : Controller
    {
        #region последовательность вызова данных из SQL БД из контроллера цепочка такая: 
        //(Браузер-URL-ProductController-IProductRepository-EFProductRepository-SQLServer- на выходе обьекты Products)
        //Когда браузер запраши ­
        //вает стандартный URL для приложения, конфигурация приложения сообщает МVС о
        //необходимости создания контроллера Product для обработки запроса. Создание кон­
        //троллера Product означает вызов конструктора класса ProductController, которо­
        //му требуется объект, реализующий интерфейс IРroductRepositorу, и новая конфи­
        //гурация указывает MVC о том, что для этого должен быть создан и применен объект
        //EFProductRepository.
        //Объект EFProductRepository обращается к функциональ­
        //ности EF Core, которая загружает реляционные данные из SQL Server и преобразует  их в объекты Products
        //Вся упомянутая работа скрыта от класса ProductController, 
        //который просто получает объект, реализующий интерфейс IProductRepository, и
        //пользуется данными, которые он предоставляет.
        #endregion
        #region вызов FakeRepository
        // Когда инфраструктуре MVC необходимо создать новый экземпляр клас­
        // са ProductController для обработки НТГР-запроса, она проинспектирует
        // конструктор и выяснит, что он требует объекта, который реализует интерфейс
        // IProductRepository. Чтобы определить.какой класс реализации должен исполь­
        // зоваться, инфраструктура МVС обращается к конфигурации в классе Startup, ко­
        // торая сообщает о том, что необходимо применять класс FakeRepository, а также о
        // том, что каждый раз должен создаваться его новый экземпляр. Инфраструктура MVC
        // создает новый объект FakeRepository и использует его для вызова конструктора
        // ProductController с целью создания объекта контроллера, который будет обраба­
        // тывать НТТР-запрос.
        // Такой подход известен под названием внедрение зависимостей и позволяет объек­
        // ту ProductController получать доступ к хранилищу приложения через интерфейс
        // IProductRepository без необходимости в знании того, какой класс реализации был
        // сконфигурирован.Позже мы заменим фиктивное хранилище реальным, а благодаря
        // внедрению зависимостей контроллер продолжит работать безо всяких изменений. 
        #endregion

        private IProductRepository repository;
        public ProductController(IProductRepository repo)
        { repository = repo; }
        // GET: /<controller>/
        #region
        // метод List будет визуализировать представление
        // Передача методу View () экземпляра List<Product> 
        // (списка объектов Product) снабжает инфраструктуру данными, которыми необходи ­
        // мо заполнить объект Model в строго типизированном представлении.
        #endregion
        //public ViewResult List() => View(repository.Products);

        #region PageSize разбиение содержимого по продуктам на страницы
        // поддержка разбиения
        // на страницы, чтобы представление отображало на странице меньшее число товаров, 
        // а пользователь мог переходить со страницы на страницу для просмотра всего каталог.

        // Поле PageSize указывает, что на одной странице должны отображаться сведения
        // о четырех товарах.
        #endregion
        public int PageSize = 4; // не более 4 товаров на 1 странице. int page = 1 это страница по умолчанию как первая стартовая

        #region внесение категории в List 
        // В List внесены три изменения добавлен новый пара­
        //метр по имени category. Он применяется вторым изменением, которое представ­
        //ляет собой расширение запроса LINQ. Если значение category не равно null,
        //тогда выбираются только объекты Products с соответствующим значением в свойс­
        //тве Category,
        //Последнее,третье, изменение касается установки значения свойс­
        //тв а CurrentCategory, которое было добавлено в класс ProductsListViewModel.
        //Однако в р е зультате таких из менений значение Paginglnfo.Totalltems вычисля ­
        //ется некорректно, потому что оно не принимает во внимание фильтр по категории.
        //Со временем мы все исправим.
        // выбор по категориям из строки https://localhost:44367/Product/List/?category=Soccer
        #endregion
        public ViewResult List(string category, int page = 1) =>
            View(new ProductsListViewModel
            {
                Products = repository.Products.Where(p => category == null || p.Category == category)
                .OrderBy(p => p.ProductID).Skip((page - 1) * PageSize).Take(PageSize),
                PagingInfo = new PagingInfo // класс модели представления
                {
                    CurrentPage = page,
                    ItemsPerPage = PageSize,
                    TotalItems = category == null ? //Создание данных о разбиении на страницы, учитывающих категории
                    repository.Products.Count() :
                    repository.Products.Where(e => e.Category == category).Count()

                    // Если категория была выбрана (category == null ?), тогда возвращается количество позиций в ней,
                    // а если нет, то общее число товаров. Теперь во время просмотра товаров в какой - либо
                    //категории ссылки в нижней части страницы корректно отражают количество товаров
                    //в этой категории
                },
                CurrentCategory = category

            });
        // в данном контроллере List мы создаем экземпляры двух класов первый ProductsListViewModel который 
        // получает данные из БД и фильтрует описанным выше образом, и экз класса PagingInfo который  
        // обеспечивает поддержку дескрипторного вспомогательного класса PageLinkTagHelper передавая ему нужную информацию 
        // о количестве доступных страниц, текущей странице и общем числе товаров в хранилище по мнению автора книги это самый простой 
        // способ передачи данных между контроллером и представлением.
        // В итоге Внесенные изменения обеспечивают передачу представлению объекта.
        //------
        //ProductsListViewModel класс данных модели.
        //Skip Пропускает заданное число элементов в последовательности и возвращает остальные элементы.
        //Take Возвращает указанное число подряд идущих элементов с начала последовательности.

    }
}
